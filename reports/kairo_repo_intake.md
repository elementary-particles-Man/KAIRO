# Repository Overview
- Root `Cargo.toml` defines a multi-crate workspace spanning `rust-core`, several `src/*` services, and `Kairo-Nexus`, wiring every binary against the shared `kairo_core`/`kairo_lib` crates (Cargo.toml:29-41).
- `rust-core` concentrates protocol primitives such as mesh analytics, FlatBuffers bindings, packet parsing/validation, signing, and trust tooling, exposing them as modules from a single crate for reuse (rust-core/src/lib.rs:2-18).
- `src/kairo-lib` re-exports config, registry, packet, communication, governance, and WAU scope helpers so both binaries and utilities can share serialization and signing logic (src/kairo-lib/lib.rs:3-20).
- Documentation and schemas describe the intended AI-TCP/KAIRO-P flows (`docs/RFC/AI-TCP_RFC_mesh_layered_architecture.md:5-66`, `docs/kairo_daemon_api.md:5-54`, `schema/ai_tcp_packet.fbs:7-20`) and serve as the canonical spec for packet shapes and daemon endpoints.
- Go support is split between an HTTP client with adaptive backoff (`go-client/client.go:1-161`) and a nascent FlatBuffers serializer meant for P2P packet emission but still filled with zeroed cryptographic fields (`go-p2p/pkg/serializer.go:8-32`).
- Operational interfaces include the Axum-based `kairo-daemon`, Warp-based mesh/seed services, and the `src/bot` HTTP facade that fronts the static `Kairobot` UI served from `vov/kairobot_ui/index.html` (src/bot/main.rs:1-127; vov/kairobot_ui/index.html:1-40).

# Module Topology
- **Core crypto & parsing** – `rust-core` surfaces FlatBuffers builders, packet validation, Ed25519 + SHA-256 signing, and HMAC log recording that higher layers depend on for envelope integrity (rust-core/src/packet_validator.rs:5-94; rust-core/src/signature.rs:5-56; rust-core/src/log_recorder.rs:1-92).
- **Shared library** – `src/kairo-lib` houses `AgentConfig`, registry locking, JSON `AiTcpPacket`, governance structs, WAU scope logic, and simple message signing so every binary shares the same persistence and signature formats (src/kairo-lib/config.rs:23-142; src/kairo-lib/registry.rs:7-90; src/kairo-lib/comm.rs:1-24; src/kairo-lib/governance.rs:1-25).
- **Agent CLIs** – `signed_sender`, `receive_signed`, and `setup_agent` provide onboarding plus signed send/receive loops, but currently fabricate addresses and operate against local JSON stores without hardened daemon integration (src/agent/signed_sender.rs:7-102; src/agent/receive_signed.rs:1-125; src/agent/setup_agent.rs:47-163).
- **Daemon layer** – Two parallel implementations exist: the older Warp-based `src/kairo_daemon` that handles `/send`/`/receive`/`request_address` with in-memory queues (src/kairo_daemon/src/main.rs:17-99) and the newer Axum service under `src/kairo-daemon` that exposes `/send`, `/gpt`, and `/add_task` plus a TCP listener bridge (src/kairo-daemon/main.rs:1-59; src/kairo-daemon/kairo_p_listener.rs:8-71; src/kairo-daemon/handle_send.rs:5-33).
- **Mesh & seed nodes** – `src/mesh-node` and `src/server/seed_node.rs` implement registries, revocation/reissue flows, and per-P-address queues guarded by ed25519 verification, effectively acting as the registry backbone for the mesh (src/mesh-node/main.rs:1-102; src/mesh-node/seed_node.rs:10-149; src/server/seed_node.rs:1-335).
- **Governance utilities** – CLI tools under `src/governance` orchestrate override packages by composing/singing `OverridePackage` payloads defined in `kairo-lib`, enabling multi-signature emergency flows (src/governance/propose_override.rs:1-99; src/governance/sign_override.rs:1-73; src/kairo-lib/governance.rs:1-25).
- **Go adapters** – The HTTP client and FlatBuffers serializer provide non-Rust entry points but lack full crypto enforcement, indicating they are mainly scaffolding for future integrations (go-client/client.go:1-161; go-p2p/pkg/serializer.go:8-32).
- **UI/automation** – `src/bot` spins up a Warp server that signs placeholder FlatBuffer packets on behalf of `users/CLI/cli_identity.json` and serves the static `Kairobot` UI for manual packet submission (src/bot/main.rs:1-127; vov/kairobot_ui/index.html:1-40).

# KAIRO-P Address Model (ID/Nick/Encoding)
- Agent identities store `p_address`, public/secret keys, signature, and a last sequence in `AgentConfig`, with validation enforcing CIDR-like strings and 64-hex key encodings (src/kairo-lib/config.rs:23-142).
- The registry keeps `(name, p_address)` pairs plus soft-deletion flags, ensuring both names and P-addresses remain unique; there is no nickname field beyond the `name` string, and the `AgentMapping` struct inside `setup_agent` still comments out any `p_address` usage (src/kairo-lib/registry.rs:7-90; src/agent/setup_agent.rs:41-45).
- `setup_agent` sanitizes the requested name but currently skips daemon assignment, instead minting a dummy `10.0.0.x/24` address and logging that both daemon assignment and seed-node registration are “not implemented,” so generated configs are self-signed but not federated (src/agent/setup_agent.rs:47-141).
- The documented daemon API targets `/assign_p_address`, `/send`, and `/receive/{p_address}`, while the Warp daemon implements `/request_address` that simply increments an in-memory counter, meaning there is no persisted pool or subnet enforcement yet (docs/kairo_daemon_api.md:5-54; src/kairo_daemon/src/main.rs:51-99).
- RFC 10 outlines the agent → daemon → agent pipeline, signature responsibilities, and the plan for multi-daemon mesh forwarding backed by `seed_node.rs`, but the actual seed-node implementations only track status/public_key timestamps and do not yet broker cross-daemon routing (docs/RFC/AI-TCP_RFC_mesh_layered_architecture.md:5-66; src/mesh-node/seed_node.rs:10-149; src/server/seed_node.rs:69-249).
- `NodeManager` under `rust-core` issues 128-bit UUID strings and allocates `100.64.0.0/10` addresses, yet nothing wires that allocator into the P-address flow, so IDs and nicknames remain ad-hoc (rust-core/src/coordination/node_manager.rs:7-61).

# Witness Pipeline (record size, rotation, hashing)
- The only witness-like component today is `LogRecorder`, which maintains a 32-byte HMAC-SHA256 key, rotates it on demand, and can export/recover state by embedding the key material and timestamp into an `AITcpPacket` FlatBuffer blob (rust-core/src/log_recorder.rs:1-92).
- Packet structure expectations are constrained via the FlatBuffers schema (version + required vectors) and the validator that enforces 8-byte sequence IDs and 64-byte signatures before delegating to Ed25519 verification, defining the effective record size for encrypted payloads (schema/ai_tcp_packet.fbs:7-20; rust-core/src/packet_validator.rs:41-93).
- There is no code path that invokes `LogRecorder` from the daemons or agents, and a repository-wide search for “witness” yields no references, so the hashing/rotation logic is not yet part of an auditable evidence pipeline.
- Without retention policies or rolling file formats, witness records are just standalone FlatBuffer dumps; hashing is limited to single-key HMAC values and is not chained or anchored to an external log, leaving rotation and record-size controls unenforced outside the helper itself (rust-core/src/log_recorder.rs:52-92).

# ISE Engine Hooks (sign/transform/mapping)
- The Axum daemon’s `handle_send` only accepts packets destined for `gpt://main`, delegates verification to a stub that always returns `true`, and rejects every other destination, so no transformation/mapping hooks exist for generalized ISE flows (src/kairo-daemon/handle_send.rs:5-33; src/kairo-daemon/p_signature_validator.rs:1-7).
- The supposed structural/threat analysis step is a placeholder that merely logs “Checking for ASI/DeepSeek structures” and returns `false`, providing no ISE enforcement or mapping (src/kairo-daemon/p_structure_filter.rs:1-4).
- GPT handling is simulated via `gpt_responder.rs`, which echoes the inbound packet into a JSON response with a placeholder signature, meaning there is no actual transform pipeline or chain of custody (src/kairo-daemon/gpt_responder.rs:5-26).
- The TCP listener simply forwards JSON packets to the Warp daemon’s `/send` endpoint without interception, so there are no boundary hooks where an ISE engine could observe, sign, or re-map content (src/kairo-daemon/kairo_p_listener.rs:8-71).

# Gaps vs CLEAR-Mini Spec
- **Authoritative P-addressing** – CLI onboarding logs that daemon assignment/seed registration are unimplemented and falls back to random `/24` addresses, while the daemon’s `/request_address` allocator is in-memory only; any CLEAR-Mini requirement for deterministic issuance or revocation therefore cannot be met (src/agent/setup_agent.rs:108-118; src/kairo_daemon/src/main.rs:75-99).
- **Witness expectations** – Although HMAC rotation helpers exist, no runtime code calls them and no files reference “witness,” so there is no actual witness feed, making it impossible to satisfy CLEAR-Mini’s witness size/rotation mandates (rust-core/src/log_recorder.rs:1-92).
- **Signature enforcement** – `p_signature_validator` always returns `true`, yet `handle_send` logs “signature invalid” branches that can never execute, and it even expects a `Packet` type absent from `kairo-lib`, indicating the path would fail to compile and cannot enforce CLEAR-grade validation (src/kairo-daemon/p_signature_validator.rs:1-7; src/kairo-daemon/handle_send.rs:5-33; src/kairo-lib/packet.rs:5-18).
- **ISE coverage** – No code or docs reference “ISE,” and the only filtering/responder modules are stubs, so any CLEAR-Mini hooks for transform/mapping are missing entirely (src/kairo-daemon/p_structure_filter.rs:1-4; src/kairo-daemon/gpt_responder.rs:5-26).
- **Client/TypeScript parity** – The requested TypeScript API map cannot be produced because the repository has no `.ts` sources; the UI is a static HTML+inline JS file, meaning CLEAR-Mini compatible TS SDKs are absent (vov/kairobot_ui/index.html:1-40).
- **Go cryptography** – The FlatBuffers serializer fills ephemeral keys, nonces, and signatures with zero bytes, so any CLEAR-Mini compliance for 128-bit entropy, ring handling, or TPM-backed sealing is currently unimplemented (go-p2p/pkg/serializer.go:8-32).
- **Dual daemon divergence** – Maintaining both `src/kairo_daemon` and `src/kairo-daemon` with different port conventions and queue types risks behavioral drift and makes it unclear which one, if any, adheres to the CLEAR-Mini spec (src/kairo-daemon/main.rs:1-59; src/kairo_daemon/src/main.rs:17-99).

# Recommended Extraction Stubs
1. **`agent_registry_dump.rs`** – Reuse `load_registry`/`RegistryEntry` to emit a normalized CSV of names, P-addresses, and deletion flags for downstream analysis without touching live daemons (src/kairo-lib/registry.rs:17-90).
2. **`queue_snapshot.rs`** – Add a debug-only route next to `handle_receive` that clones `MESSAGE_QUEUE` and returns pending packets plus source metadata so investigators can capture in-flight envelopes (src/kairo_daemon/src/main.rs:51-72).
3. **`witness_log_snapshot.rs`** – Wrap `LogRecorder::export_flatbuffers` to dump HMAC keys + timestamps on demand, pairing the output with SHA-256 digests for tamper checks (rust-core/src/log_recorder.rs:52-92).
4. **`seed_registry_export.rs`** – Extend the seed-node service with a signed `/registry_snapshot` handler that streams the JSON registry and override history for auditors (src/server/seed_node.rs:1-218).
5. **`flatbuffer_packet_fuzzer.go`** – Build on the Go serializer to emit randomized payloads with real ed25519 signatures, enabling CI replay/fuzzing against the Rust packet validator (go-p2p/pkg/serializer.go:8-32; rust-core/src/packet_validator.rs:34-93).
